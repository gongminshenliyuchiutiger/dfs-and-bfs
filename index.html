<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超神系列 | DFS 與 BFS 演算法展演系統</title>
    <meta name="description" content="超神系列：深度優先搜尋與廣度優先搜尋的視覺化駭客風格教學。">
    
    <!-- 引入 Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 引入 Google Fonts (科幻字體) -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+TC:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- 變數定義：賽博龐克配色 (與雜湊網站統一) --- */
        :root {
            --bg-color: #0a0b1e;
            --card-bg: rgba(255, 255, 255, 0.03);
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-green: #0aff68;
            --neon-orange: #ff9f43;
            --neon-red: #ff4757;
            --text-main: #ffffff;
            --text-muted: #a0a0b0;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            /* 動態網格背景 */
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: moveGrid 20s linear infinite;
            overflow-x: hidden;
        }

        @keyframes moveGrid {
            0% { background-position: 0 0; }
            100% { background-position: 40px 40px; }
        }

        /* --- Header --- */
        header {
            background: rgba(10, 11, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 1px solid rgba(0, 243, 255, 0.1);
        }

        h1 { 
            font-family: 'Orbitron', sans-serif; 
            margin: 0; 
            font-size: 2rem; 
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--neon-blue), var(--text-main), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        nav { margin-top: 15px; }
        nav a { 
            color: var(--text-muted); 
            text-decoration: none; 
            margin: 0 15px; 
            font-size: 0.9rem; 
            transition: 0.3s; 
            position: relative;
        }
        nav a:hover { color: var(--neon-blue); text-shadow: 0 0 5px var(--neon-blue); }

        /* --- Layout --- */
        main { max-width: 1100px; margin: 40px auto; padding: 0 20px; flex: 1; }

        /* --- 玻璃擬態卡片 --- */
        .card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 2.5rem;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: transform 0.3s;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 3px; height: 100%;
            background: linear-gradient(to bottom, var(--neon-blue), var(--neon-purple));
        }

        .card:hover { transform: translateY(-3px); box-shadow: 0 10px 40px rgba(0, 243, 255, 0.05); }

        h2 { 
            font-family: 'Orbitron', sans-serif; 
            color: var(--neon-blue); 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            padding-bottom: 15px; 
            margin-top: 0; 
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        h3 { color: var(--neon-purple); margin-top: 25px; font-size: 1.3rem; }
        p { line-height: 1.8; color: #ccc; }
        strong { color: var(--neon-green); }

        /* --- 數據結構視覺化 --- */
        .ds-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .ds-box {
            background: rgba(0,0,0,0.3);
            border: 1px dashed rgba(255,255,255,0.2);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .viz-queue { 
            display: flex; justify-content: center; gap: 10px; margin-top: 15px; 
        }
        .viz-item {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            font-family: monospace;
        }

        /* --- Canvas 畫布 --- */
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 0 30px rgba(0, 243, 255, 0.1);
        }
        
        #graphCanvas { width: 100%; max-width: 800px; height: auto; border-radius: 10px; }

        /* --- 控制面板 --- */
        .controls { 
            display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; justify-content: center; width: 100%;
        }

        select {
            background: #0a0b1e; color: var(--neon-blue); border: 1px solid var(--neon-blue);
            padding: 10px; border-radius: 5px; font-family: 'Orbitron'; outline: none;
        }

        button {
            background: rgba(0, 243, 255, 0.1);
            color: var(--neon-blue);
            border: 1px solid var(--neon-blue);
            padding: 10px 25px;
            font-size: 1rem;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            border-radius: 5px;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover:not(:disabled) {
            background: var(--neon-blue); color: #000;
            box-shadow: 0 0 15px var(--neon-blue);
        }

        button:disabled {
            border-color: #444; color: #666; cursor: not-allowed; background: transparent;
        }

        /* 特別按鈕樣式 */
        #startDFS { border-color: var(--neon-red); color: var(--neon-red); }
        #startDFS:hover { background: var(--neon-red); color: #fff; box-shadow: 0 0 15px var(--neon-red); }

        #startBFS { border-color: var(--neon-green); color: var(--neon-green); }
        #startBFS:hover { background: var(--neon-green); color: #000; box-shadow: 0 0 15px var(--neon-green); }

        /* --- 狀態面板 --- */
        .status-panel {
            width: 100%; margin-top: 20px; padding: 15px;
            background: rgba(0,0,0,0.6); border-left: 4px solid var(--neon-orange);
            border-radius: 5px; font-family: 'Courier New', monospace;
        }
        .status-label { color: var(--text-muted); font-size: 0.9rem; }
        .status-val { color: var(--neon-orange); font-weight: bold; }

        /* --- 表格樣式 --- */
        .comparison-table {
            width: 100%; border-collapse: collapse; margin-top: 20px;
            color: #ddd;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid rgba(255,255,255,0.1); padding: 15px; text-align: left;
        }
        .comparison-table th {
            background: rgba(0, 243, 255, 0.1); color: var(--neon-blue);
        }
        .comparison-table tr:hover { background: rgba(255,255,255,0.05); }

        /* --- 吉祥物 --- */
        .mascot-container {
            position: fixed; bottom: 20px; left: 20px; z-index: 2000; cursor: pointer; width: 120px;
        }
        .mascot-img {
            width: 100%; height: auto; transition: 0.3s;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }
        .mascot-container:hover .mascot-img {
            animation: shake 0.5s infinite, neon-pulse 1s infinite alternate;
        }

        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 100% { transform: translate(-1px, -1px) rotate(-1deg); } }
        @keyframes neon-pulse { from { filter: drop-shadow(0 0 5px var(--neon-blue)); } to { filter: drop-shadow(0 0 15px var(--neon-purple)); } }

        footer {
            text-align: center; padding: 20px; color: #666; font-size: 0.9rem;
            border-top: 1px solid rgba(255,255,255,0.05); margin-top: auto;
        }

        /* RWD */
        @media (max-width: 768px) {
            .ds-grid { grid-template-columns: 1fr; }
            .controls { flex-direction: column; width: 100%; }
            button, select { width: 100%; }
        }
    </style>
</head>
<body>

    <header>
        <h1>超神系列 | DFS 與 BFS 演算法展演系統</h1>
        <nav>
            <a href="#intro"><i class="fas fa-info-circle"></i> 簡介</a>
            <a href="#datastructures"><i class="fas fa-database"></i> 核心結構</a>
            <a href="#visualization"><i class="fas fa-eye"></i> 視覺化實驗</a>
            <a href="#theory"><i class="fas fa-flask"></i> 理論比較</a>
        </nav>
    </header>

    <main>
        
        <!-- 1. 簡介 -->
        <section id="intro" class="card">
            <h2><i class="fas fa-network-wired"></i> 圖形遍歷 (Graph Traversal)</h2>
            <p>歡迎來到演算法的數位世界。在這裡，我們將探索兩個最經典的搜索程式：<strong>DFS (深度優先)</strong> 與 <strong>BFS (廣度優先)</strong>。想像你是一個網路爬蟲，這兩種方法決定了你如何在龐大的網路節點中移動。</p>
        </section>

        <!-- 2. 數據結構 -->
        <section id="datastructures" class="card">
            <h2><i class="fas fa-microchip"></i> 核心引擎：Stack vs Queue</h2>
            <p>這兩種演算法的行為差異，完全取決於它們「暫存記憶體」的運作方式。</p>

            <div class="ds-grid">
                <div class="ds-box">
                    <h3 style="color: var(--neon-red);"><i class="fas fa-layer-group"></i> 堆疊 (Stack)</h3>
                    <p style="font-size: 0.9rem;"><strong>DFS 的核心 (LIFO)</strong></p>
                    <div class="viz-queue" style="flex-direction: column-reverse; align-items: center;">
                        <div class="viz-item" style="border-color: var(--neon-red); color: var(--neon-red);">數據 C (最新)</div>
                        <div class="viz-item" style="border-color: #555; color: #777;">數據 B</div>
                        <div class="viz-item" style="border-color: #555; color: #777;">數據 A (最舊)</div>
                    </div>
                    <p style="font-size: 0.8rem; margin-top:10px;">"後進先出：像裝填子彈，最後裝的先擊發"</p>
                </div>
                
                <div class="ds-box">
                    <h3 style="color: var(--neon-green);"><i class="fas fa-people-arrows"></i> 佇列 (Queue)</h3>
                    <p style="font-size: 0.9rem;"><strong>BFS 的核心 (FIFO)</strong></p>
                    <div class="viz-queue">
                        <div class="viz-item" style="border-color: var(--neon-green); color: var(--neon-green);">數據 A</div>
                        <div class="viz-item" style="border-color: #555; color: #777;">數據 B</div>
                        <div class="viz-item" style="border-color: #555; color: #777;">數據 C</div>
                    </div>
                    <p style="font-size: 0.8rem; margin-top:10px;">"先進先出：像排隊買票，先來的先服務"</p>
                </div>
            </div>
        </section>

        <!-- 3. 視覺化展演 -->
        <section id="visualization" class="card">
            <h2><i class="fas fa-vr-cardboard"></i> 互動實驗室</h2>
            <p>選擇起點與演算法，啟動掃描程序。觀察節點如何被點亮，以及連線如何傳導。</p>
            
            <div class="canvas-container">
                <div class="controls">
                    <label><i class="fas fa-location-crosshairs"></i> 起點:</label>
                    <select id="startNodeSelect">
                        <option value="A">節點 A</option>
                        <option value="B">節點 B</option>
                        <option value="C">節點 C</option>
                        <option value="D">節點 D</option>
                        <option value="E">節點 E</option>
                        <option value="F">節點 F</option>
                    </select>
                    
                    <button id="startDFS" onclick="startVisualization('DFS')"><i class="fas fa-bolt"></i> 啟動 DFS (深度)</button>
                    <button id="startBFS" onclick="startVisualization('BFS')"><i class="fas fa-wifi"></i> 啟動 BFS (廣度)</button>
                    <button id="nextStep" onclick="stepAlgorithm()" disabled><i class="fas fa-forward"></i> 下一步</button>
                    <button id="resetBtn" onclick="resetGraph()"><i class="fas fa-rotate-right"></i> 系統重置</button>
                </div>

                <canvas id="graphCanvas" width="800" height="450"></canvas>

                <div class="status-panel">
                    <div><span class="status-label">執行程序:</span> <span class="status-val" id="currentAlgo" style="color:var(--neon-blue)">待命</span></div>
                    <div style="margin-top:5px;"><span class="status-label">系統狀態:</span> <span id="currentStatus" style="color:#fff;">請選擇模式</span></div>
                    <div style="margin-top:5px;"><span class="status-label">掃描順序:</span> <span id="visitOrder" style="color:var(--neon-green); font-family: monospace;"></span></div>
                    <div style="border-top: 1px dashed #444; margin-top:10px; padding-top:10px;">
                        <span class="status-label">記憶體結構:</span> <span id="dataStructure" style="color:var(--neon-orange)">[]</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- 4. 理論比較 -->
        <section id="theory" class="card">
            <h2><i class="fas fa-scale-balanced"></i> 演算法分析矩陣</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>特徵</th>
                        <th><i class="fas fa-arrow-down"></i> DFS (深度優先)</th>
                        <th><i class="fas fa-expand"></i> BFS (廣度優先)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>核心邏輯</strong></td>
                        <td style="color:var(--neon-red)">一條路走到黑 (撞牆才回頭)</td>
                        <td style="color:var(--neon-green)">地毯式搜索 (層層推進)</td>
                    </tr>
                    <tr>
                        <td><strong>數據結構</strong></td>
                        <td>Stack (堆疊) / 遞迴</td>
                        <td>Queue (佇列)</td>
                    </tr>
                    <tr>
                        <td><strong>最短路徑?</strong></td>
                        <td>不保證</td>
                        <td><strong>保證</strong> (在無權重圖中)</td>
                    </tr>
                    <tr>
                        <td><strong>最佳應用</strong></td>
                        <td>走迷宮、拓撲排序、判斷連通性</td>
                        <td>導航系統 (GPS)、社交網路好友推薦</td>
                    </tr>
                </tbody>
            </table>
        </section>

    </main>

    <!-- 吉祥物 -->
    <div class="mascot-container">
        <!-- 確保 image/LiyuChillGuy.svg 存在 -->
        <img src="image/LiyuChillGuy.svg" alt="LiyuChillGuy" class="mascot-img">
    </div>

    <footer>
        Copyright © Liyuchiutiger Gongminshen
    </footer>

    <!-- JS 邏輯 -->
    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const NODE_RADIUS = 25;

        // 圖結構數據
        const graphData = {
            'A': { x: 100, y: 200, neighbors: ['B', 'C'] },
            'B': { x: 250, y: 100, neighbors: ['A', 'C', 'D'] },
            'C': { x: 250, y: 300, neighbors: ['A', 'B', 'D', 'E'] },
            'D': { x: 450, y: 100, neighbors: ['B', 'C', 'E', 'F'] },
            'E': { x: 450, y: 300, neighbors: ['C', 'D'] },
            'F': { x: 650, y: 100, neighbors: ['D'] }
        };
        
        let visited = new Set();
        let traversalQueue = []; 
        let currentAlgorithm = null;
        let visitOrder = [];

        // 霓虹配色定義
        const COLOR_DEFAULT_STROKE = '#00f3ff'; // 藍色
        const COLOR_DEFAULT_FILL = 'rgba(0, 243, 255, 0.1)';
        
        const COLOR_VISITED_STROKE = '#0aff68'; // 綠色
        const COLOR_VISITED_FILL = 'rgba(10, 255, 104, 0.2)';
        
        const COLOR_ACTIVE_STROKE = '#ff4757'; // 紅色 (當前焦點)
        const COLOR_ACTIVE_FILL = 'rgba(255, 71, 87, 0.3)';
        
        const COLOR_QUEUE_STROKE = '#ff9f43'; // 橘色 (待辦)
        const COLOR_QUEUE_FILL = 'rgba(255, 159, 67, 0.2)';

        /* --- 繪圖函數 (Cyberpunk 風格) --- */
        function drawNode(key, strokeColor, fillColor, isGlowing = false) {
            const node = graphData[key];
            
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
            
            // 發光特效
            if (isGlowing) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = strokeColor;
            } else {
                ctx.shadowBlur = 0;
            }

            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 3;
            ctx.stroke();

            // 重置陰影以免影響文字
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 18px "Orbitron", sans-serif';
            ctx.fillText(key, node.x, node.y);
        }

        function drawEdge(nodeKey1, nodeKey2) {
            const n1 = graphData[nodeKey1];
            const n2 = graphData[nodeKey2];
            
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // 預設暗淡連線
            ctx.lineWidth = 1;
            
            // 如果兩端都訪問過，連線變亮
            if (visited.has(nodeKey1) && visited.has(nodeKey2)) {
                 ctx.strokeStyle = 'rgba(10, 255, 104, 0.6)'; // 綠色連線
                 ctx.lineWidth = 2;
                 ctx.shadowBlur = 10;
                 ctx.shadowColor = '#0aff68';
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 繪製連線
            const drawnEdges = new Set();
            for (const key in graphData) {
                graphData[key].neighbors.forEach(neighborKey => {
                    const edgeId = [key, neighborKey].sort().join('-');
                    if (!drawnEdges.has(edgeId)) {
                        drawEdge(key, neighborKey);
                        drawnEdges.add(edgeId);
                    }
                });
            }

            // 2. 繪製節點
            for (const key in graphData) {
                let stroke = COLOR_DEFAULT_STROKE;
                let fill = COLOR_DEFAULT_FILL;
                let glow = false;

                if (visited.has(key)) {
                    stroke = COLOR_VISITED_STROKE;
                    fill = COLOR_VISITED_FILL;
                }
                
                if (traversalQueue.includes(key)) {
                    stroke = COLOR_QUEUE_STROKE;
                    fill = COLOR_QUEUE_FILL;
                }

                // 判斷當前正要處理的節點
                let nextNode = traversalQueue.length > 0 ? 
                               (currentAlgorithm === 'BFS' ? traversalQueue[0] : traversalQueue[traversalQueue.length - 1]) : null;

                if (key === nextNode) {
                    stroke = COLOR_ACTIVE_STROKE;
                    fill = COLOR_ACTIVE_FILL;
                    glow = true; // 只有當前節點發光
                }

                drawNode(key, stroke, fill, glow);
            }
        }
        
        /* --- 狀態與邏輯 --- */
        function updateStatus() {
            const algoLabel = document.getElementById('currentAlgo');
            const statusText = document.getElementById('currentStatus');
            
            algoLabel.innerText = currentAlgorithm || '待命';
            
            if (traversalQueue.length > 0) {
                statusText.innerText = '運算中... 請點擊「下一步」';
                statusText.style.color = 'var(--neon-blue)';
            } else if (currentAlgorithm) {
                statusText.innerText = '掃描完成。';
                statusText.style.color = 'var(--neon-green)';
            } else {
                statusText.innerText = '請選擇模式';
            }
            
            let displayQueue = [...traversalQueue]; 
            const dsElement = document.getElementById('dataStructure');

            if (currentAlgorithm === 'DFS') {
                dsElement.innerHTML = 
                    `STACK: [${displayQueue.join(', ')}] <span style="color:#666">← TOP</span>`;
            } else if (currentAlgorithm === 'BFS') {
                 dsElement.innerHTML = 
                    `QUEUE: <span style="color:#666">OUT ←</span> [${displayQueue.join(', ')}] <span style="color:#666">← IN</span>`;
            } else {
                 dsElement.innerHTML = '[]';
            }
            
            document.getElementById('visitOrder').innerText = visitOrder.join(' → ');
            drawGraph();
            
            // 按鈕狀態
            const nextBtn = document.getElementById('nextStep');
            nextBtn.disabled = traversalQueue.length === 0;
            
            // 如果可以下一步，給按鈕加強烈發光效果
            if (!nextBtn.disabled) {
                nextBtn.style.boxShadow = "0 0 15px var(--neon-blue)";
            } else {
                nextBtn.style.boxShadow = "none";
            }
        }

        function stepAlgorithm() {
            if (traversalQueue.length === 0) {
                updateStatus();
                return;
            }

            let currentNodeKey;
            
            if (currentAlgorithm === 'BFS') {
                currentNodeKey = traversalQueue.shift(); 
            } else if (currentAlgorithm === 'DFS') {
                currentNodeKey = traversalQueue.pop(); 
            }
            
            if (visited.has(currentNodeKey)) {
                 updateStatus(); 
                 return;
            }

            visited.add(currentNodeKey);
            visitOrder.push(currentNodeKey);

            const neighbors = graphData[currentNodeKey].neighbors;
            
            // 排序並過濾
            const unvisitedNeighbors = neighbors
                .filter(n => !visited.has(n) && !traversalQueue.includes(n))
                .sort(); 

            if (currentAlgorithm === 'DFS') {
                 // DFS (Stack): 逆序推入，讓字母序小的在 Top
                 unvisitedNeighbors.slice().reverse().forEach(neighborKey => { 
                    traversalQueue.push(neighborKey);
                });
            } else if (currentAlgorithm === 'BFS') {
                // BFS (Queue): 順序推入
                unvisitedNeighbors.forEach(neighborKey => {
                    traversalQueue.push(neighborKey);
                });
            }

            updateStatus();
        }

        function resetGraph() {
            visited = new Set();
            traversalQueue = [];
            currentAlgorithm = null;
            visitOrder = [];
            document.getElementById('visitOrder').innerText = '';
            updateStatus();
        }

        function startVisualization(algorithm) {
            resetGraph();
            currentAlgorithm = algorithm;
            const startNode = document.getElementById('startNodeSelect').value;
            traversalQueue.push(startNode);
            updateStatus();
        }
        
        // 初始化
        window.onload = drawGraph;
        window.onresize = drawGraph; // 簡單的響應式重繪
    </script>
</body>
</html>